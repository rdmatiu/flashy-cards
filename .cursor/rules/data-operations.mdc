---
alwaysApply: true
---

# Data Operations & Server Architecture

This project follows strict server-side data handling patterns with Next.js App Router.

## üö® CRITICAL RULE: Database Query Functions

**ALL database operations MUST be implemented as helper functions in the `src/db/queries/` directory.**

### Absolute Requirements

‚ùå **NEVER** write raw database queries directly in Server Components
‚ùå **NEVER** write raw database queries directly in Server Actions
‚ùå **NEVER** import `db` directly in components or actions
‚ùå **NEVER** import table schemas outside of the `src/db/queries/` directory
‚úÖ **ALWAYS** create reusable query functions in `src/db/queries/`
‚úÖ **ALWAYS** import and call query functions from `src/db/queries/`
‚úÖ **ONLY** the query functions should interact with the database directly

**If you're about to write a database query outside of `src/db/queries/`, STOP and create a query function first.**

## Database Query Organization

All database operations must be organized in the `src/db/queries/` directory:

```
src/db/queries/
  ‚îú‚îÄ‚îÄ decks.ts      # All deck-related queries
  ‚îú‚îÄ‚îÄ cards.ts      # All card-related queries
  ‚îî‚îÄ‚îÄ index.ts      # Re-export all queries
```

### Query Function Pattern

**All query functions must:**

- Accept a `userId` parameter for user-scoped operations
- Include proper TypeScript types
- Handle filtering by user ownership
- Return typed data
- Be exported from their respective files

**Example Query File:**

```typescript
// src/db/queries/decks.ts
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

export async function getUserDecks(userId: string) {
	return await db
		.select()
		.from(decksTable)
		.where(eq(decksTable.userId, userId));
}

export async function getDeckById(deckId: number, userId: string) {
	const [deck] = await db
		.select()
		.from(decksTable)
		.where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)));

	return deck;
}

export async function createDeck(data: {
	userId: string;
	name: string;
	description?: string;
}) {
	const [deck] = await db.insert(decksTable).values(data).returning();

	return deck;
}

export async function updateDeck(
	deckId: number,
	userId: string,
	data: { name?: string; description?: string }
) {
	const [deck] = await db
		.update(decksTable)
		.set(data)
		.where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
		.returning();

	return deck;
}

export async function deleteDeck(deckId: number, userId: string) {
	await db
		.delete(decksTable)
		.where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)));
}
```

```typescript
// src/db/queries/index.ts
export * from './decks';
export * from './cards';
```

## Data Retrieval

**All data fetching must be done in Server Components using query functions.**

- Never fetch data in Client Components
- Use Server Components to call query functions and pass data as props to Client Components
- Import query functions from `@/db/queries`
- Never import `db` or table schemas directly in Server Components

**Example:**

```typescript
// app/dashboard/page.tsx (Server Component)
import { auth } from '@clerk/nextjs/server';
import { getUserDecks } from '@/db/queries';
import { redirect } from 'next/navigation';

export default async function DashboardPage() {
	const { userId } = await auth();

	if (!userId) {
		redirect('/');
	}

	// Use query function instead of raw database query
	const decks = await getUserDecks(userId);

	return <ClientComponent decks={decks} />;
}
```

## Data Mutations

**All database mutations (INSERT, UPDATE, DELETE) must be done via Server Actions using query functions.**

- Create Server Actions with the `'use server'` directive
- Place Server Actions in separate files (e.g., `actions.ts`) or at the top of Server Component files
- Call query functions from `@/db/queries` for all database operations
- Never perform mutations directly in Client Components
- Never perform mutations in API routes unless specifically required for external integrations
- Never import `db` or table schemas directly in Server Actions

**Example:**

```typescript
// app/decks/actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { createDeck, updateDeck, deleteDeck } from '@/db/queries';
import { redirect } from 'next/navigation';

export async function createDeckAction(data: CreateDeckInput) {
	const { userId } = await auth();

	if (!userId) {
		redirect('/');
	}

	// Use query function instead of raw database operation
	const deck = await createDeck({
		userId,
		name: data.name,
		description: data.description,
	});

	return deck;
}

export async function updateDeckAction(deckId: number, data: UpdateDeckInput) {
	const { userId } = await auth();

	if (!userId) {
		redirect('/');
	}

	// Use query function
	const deck = await updateDeck(deckId, userId, data);

	return deck;
}

export async function deleteDeckAction(deckId: number) {
	const { userId } = await auth();

	if (!userId) {
		redirect('/');
	}

	// Use query function
	await deleteDeck(deckId, userId);
}
```

## Data Validation

**All data must be validated using Zod.**

- Define Zod schemas for all inputs to Server Actions
- Validate data at the Server Action boundary before processing
- Return validation errors to the client in a structured format
- Never trust client-side data without server-side validation
- Pass validated data to query functions

**Example:**

```typescript
// app/decks/actions.ts
'use server';

import { z } from 'zod';
import { auth } from '@clerk/nextjs/server';
import { createDeck } from '@/db/queries';
import { redirect } from 'next/navigation';

// Define Zod schema
const createDeckSchema = z.object({
	name: z.string().min(1, 'Name is required').max(100),
	description: z.string().max(500).optional(),
});

// Define TypeScript type from schema
type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeckAction(data: CreateDeckInput) {
	const { userId } = await auth();

	if (!userId) {
		redirect('/');
	}

	// Validate input
	const validatedData = createDeckSchema.parse(data);

	// Use query function with validated data
	const deck = await createDeck({
		userId,
		name: validatedData.name,
		description: validatedData.description,
	});

	return deck;
}
```

## Server Action Parameters

**Never use FormData as the parameter type for Server Actions.**

- Always define proper TypeScript types for Server Action parameters
- Use Zod schemas to derive TypeScript types with `z.infer<typeof schema>`
- Parse and validate the data explicitly
- This ensures type safety and better developer experience

**‚ùå Wrong:**

```typescript
export async function createDeck(formData: FormData) {
	const name = formData.get('name'); // Type is FormDataEntryValue | null
	// No validation, no type safety
}
```

**‚úÖ Correct:**

```typescript
const createDeckSchema = z.object({
	name: z.string().min(1),
	description: z.string().optional(),
});

type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(data: CreateDeckInput) {
	const validatedData = createDeckSchema.parse(data);
	// Full type safety and validation
}
```

## Error Handling

When validation fails or operations error:

- Return structured error responses (not throw in production)
- Use discriminated unions for success/error states
- Provide user-friendly error messages

**Example:**

```typescript
// app/decks/actions.ts
'use server';

import { z } from 'zod';
import { auth } from '@clerk/nextjs/server';
import { createDeck } from '@/db/queries';
import { redirect } from 'next/navigation';

type ActionResult<T> =
	| { success: true; data: T }
	| { success: false; error: string };

const createDeckSchema = z.object({
	name: z.string().min(1, 'Name is required').max(100),
	description: z.string().max(500).optional(),
});

type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeckAction(
	data: CreateDeckInput
): Promise<ActionResult<Deck>> {
	try {
		const { userId } = await auth();

		if (!userId) {
			redirect('/');
		}

		const validatedData = createDeckSchema.parse(data);

		// Use query function
		const deck = await createDeck({
			userId,
			name: validatedData.name,
			description: validatedData.description,
		});

		return { success: true, data: deck };
	} catch (error) {
		if (error instanceof z.ZodError) {
			return { success: false, error: error.errors[0].message };
		}
		return { success: false, error: 'Failed to create deck' };
	}
}
```

## Critical Checklist

Before implementing any data operation:

- [ ] Have I created query functions in `src/db/queries/` for all database operations?
- [ ] Am I importing query functions from `@/db/queries` (not importing `db` directly)?
- [ ] Is data retrieval happening in a Server Component?
- [ ] Are mutations using Server Actions (not Client Components or API routes)?
- [ ] Is there a Zod schema defined for input validation?
- [ ] Are Server Action parameters properly typed (not FormData)?
- [ ] Is validation happening at the server boundary?
- [ ] Are errors handled and returned in a structured way?
- [ ] Do all query functions accept `userId` for user-scoped operations?

## Common Mistakes to Avoid

‚ùå **Never** write database queries directly in Server Components or Server Actions
‚ùå **Never** import `db` directly in components or actions
‚ùå **Never** import table schemas outside of `src/db/queries/`
‚ùå **Never** fetch data in Client Components (use `'use client'` only for interactivity)
‚ùå **Never** perform database mutations in Client Components
‚ùå **Never** skip Zod validation for Server Action inputs
‚ùå **Never** use `FormData` as a Server Action parameter type
‚ùå **Never** trust client data without validation
‚ùå **Never** expose database errors directly to the client
‚ùå **Never** forget to filter by `userId` in query functions for user-scoped data
